2. ## Приведите грамматику в нормальную форму Хомского:
   ```
   S -> R S   | R
   R -> a S b | c R d | a b | c d | \epsilon
   ```

   ### Устранение длинных правил
   ```
   S -> RS | R
   R -> aF | cG | ab | cd | \epsilon
   F -> Sb
   G -> Rd
   ```
   ### Удаление \epsilon правил
   Найдем \eps - порождающие терминалы:
   ```
   {R, S}
   ```
   Будем включать-выключать их
   ```
   S -> RS | R  |  S |      \epsilon
   R -> aF | cG | ab | cd | \epsilon
   F -> Sb | b
   G -> Rd | d
   ```
   Уберем все \epsilon правила
   ```
   S' -> S  | \epsilon
   S  -> RS | R  | S 
   R  -> aF | cG | ab |cd 
   F  -> Sb | b
   G  -> Rd | d
   ```
   ### Устранение цепных правил
   Найдем цепные пары
   ```
   {(S', S'), (S, S), (R, R), (F, F), (G, G), (S',S), (S, R), (S', R)}
   ```
   Добавим новые правила
   ```
   S' -> RS
   S' -> aF | cG | ab | cd
   S  -> aF | cG | ab | cd
   ```
   Удалим цепные
   ```
   S' -> RS | aF | cG | ab | cd | \epsilon
   S  -> RS | aF | cG | ab | cd
   R  -> aF | cG | ab | cd
   F  -> Sb | b
   G  -> Rd | d
   ```
   ### Удаляем бесполезные символы
   Таких нет
   ### Устранение продукций с правой частью длины 2, содержащих терминалы
   ```
   S' -> RS | AF | CG | AB | CD | \epsilon
   S  -> RS | AF | CG | AB | CD
   R  -> AF | CG | AB | CD
   F  -> SB | b
   G  -> RD | d
   A  -> a
   B  -> b
   C  -> c
   D  -> d
   ```
3. ## Является ли следующий язык контекстно-свободным? Если является, привести КС грамматику, иначе -- доказать.
   ```
   { a^m b^n | m + n > 0, (m + n) делится на 2 }
   ```

   ### Язык являтеся КС
   Приведем граматику для него.
   Когда (m + n) % 2 == 0:
   1. m = 0, n % 2 == 0
   2. n = 0, m % 2 == 0
   3. m % 2 == 0, n % 2 == 0
   4. m % 2 == 1, n % 2 == 1

   Заведем нетерминал E_a, порождающий язык слов из a четной длины и E_b аналогично
   (Even a, Even b)

   _точка_ - _конкатенация_
   ```
   E_a -> aa.E_a | E_a
   E_b -> bb.E_b | bb
   ```
   Заведем нетерминалы O_a, O_b, порождающие язык из слов a и b нечетной длины соответственно
   ```
   O_a -> a.E_a | a
   O_b -> b.E_b | b
   ```
   Теперь легко описать исходный язык
   ```
   S -> E_a | E_b | E_a.E_b | O_a.O_b