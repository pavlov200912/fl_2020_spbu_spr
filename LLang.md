# Синтаксис языка L
0. ## Пререквизиты
   
   Заведем описание простейщих штук

   ```
   DIGIT -> 0|1|2|3...|9
   LOWER -> a|b|c|d|...|x|y|z 
   UPPER -> A|B|C|D|...|X|Y|Z
   ALPH  -> LOWER | UPPER  
   SPACE* -> ('space')*
   SPACE+ -> ('space')+
   ```
   Везде где используется TERM+ или TERM* я имею в виду запись, как в регулярке
   Плюсы и умножения я буду обговаривать отдельно

   Также по умолчанию скобки - группировка, а не 
   символы скобок. Символы скобок я буду обозначать ')' и '('. Также пробелы будут обозначаться 'space', чтобы точно понять.
   Если видно пробел, но не написано 'space', имеется в виду конкатенация. (Это все обозначения для MarkDown, а не для языка если что в языке пробелы обычные и скобки тоже)

   (Ремарка для выражения уважительного отношения к Екатерине Андреевне). В вольном описании языка я могу обращаться к читателю в странной манере. Обращение идет именно к абстрактному читателю, который будет когда-то писать на моем языке и читает документацию, а не лично к проверяющему.  
2. ## Идентификаторы
   
   Мне ужасно не нравятся имена вида this_is_name, но и thisIsName тоже выглядит очень плохо. В моем языке вместо _ будет ~ , чтобы все страдали.
   Идентификатор - буквы латинского алфавита, потом неотрицательное число букв или цифр или ~

    P.S Смотри раздел разделители, там объясняется взаимосвязь ключевых слов и IDENT
   ```
   IDENT -> (ALPH)+ (ALPH | DIGIT | ~)*
   ```
   
6. ## Числа

    Все числа типа 1.123e12 запрещены навсегда. Не люблю и не понимаю запись с 'e', поэтому пишите длинные числа руками. 

    Числа типа .212 .5 1. и что-то такое тоже запрещены.

    Лидирующие нули разрешены. Если вам очень хочется - пишите.

    Итого
    ```
    NUM -> (DIGIT)+ ('.' (DIGIT)+)?
    ```

    Запись +1, ++2 запрещена. Унарных плюсов вообще нет. 

    Кроме того, унарных минусов тоже нет. Если вам хочется завести отрицательное число - есть бинарный минус
    ```
    0 - 2
    ```

4. ## Общие составляющие
    Есть выражения, состоящие из бинарных операторов, чисел и идентификаторов. 

    ```
    EXPR -> '('EXPR')' | IDENT | NUM
    ```

    Есть инструкции, которые начинаются с ключевых слов и могут содержать внутри блоки с инструкциями, идентификаторами, выражениями.

    
3. ## Ключевые слова
   
   ```
   KEY -> esle | poka | := | read | print | {} | please | help | me 
   ```


   Ключевые слова
   ```
   please, help, me
   ```
   
   **aбзац недействителен** _Не обозначают ничего в LAST, заменяются на пробел при первичном синтаксическом анализе и нужны только для того, чтобы выразить семантику отчаяния и уныния в языке._  

    **правка от 02.04.20**
     _По многочисленным просьбам программистов, было решено ослабить гайки и не вырезать подстроки please, help, me отовсюду при первичном анализе. Результат всенародного голосвания: 76,69 % проголосовало за ~~Путина~~ внесение поправки_

    Не обозначают ничего в LAst, парсятся как и другие ключевые слова, но ни во что не транслируются, и нужны только для того, чтобы выразить семантику отчаяния и уныния в языке. Эти ключевые слова не должны отделяться точкой с запятой.  


   По рекомендации специалиста будет установлен следующий регламент для использования Seq:
   {} - последовательность инструкций. Примеры трансляции {} в AST: 
   ```
   {} --> Seq [] 
   { instr } --> Seq [instr]
   { instr1; instr2; ...; instr n } -> Seq [instr1, instr2, ..., instr n]
   ```  

   Синтаксис для esle:
   ```
   esle 'space' '(' EXPR ')' 'space' then 'space' '{' LAST '}' 'space' else 'space' '{' LAST '}' ';'
   ```
   Пример:
   ```
   esle (x == 0) then {x := 1;} else {x := 2;};
   ```

   Синтаксис для read:
   ```
   read '('  Var')' ';'
   ```
   Синтаксис для print:
   ```
   print '(' Expr ')' ';'
   ```
   Синтаксис для := 
   ```
   Var 'space' := 'space' Expr ';'
   ```
   Синтакси для poka
   ```
   poka 'space' '(' AST ')' 'space' '{' LAST '}' ';'
   ```
   Пример:
   ```
   poka (x > 0) {x := x + 1;};
   ```
4. ## Разделители
    С символом '\n' делайте что хотите, мне лень его парсить ставьте куда хотите, мне все равно. Если вы его поставите это ваша проблема. Все символы '\n' удаляются при первичном синтаксическом анализе и заменяются на пробел.

    Точки с запятой. После каждой инструкции, использующей ключевое слово, должна идти точка с запятой. (См синтаксис ключевых слов) (кроме please help me) 

    Точки с запятой не ставятся после ключевого слова seq, т.е после {}

    Между инструкциями, которые заканчиваются на точку с запятой может быть произвольное положительное количество пробелов. 

    Ключевые слова парсятся раньше, чем идентификаторы. Если вы хотите сделать идентификатор please или else, мне вас очень жаль, у вас не получится. 

5. ## Синтаксический сахар

    Его нет.

    Это грустно и вы можете заявить об этом, когда будете писать программу
    ```
    please help me
    ```


7. ## Операторы

    ```
    BINOP -> == | /= | < | > | <= | => | + | - | * |    / | ^ | && | || 
    ```

    Все операторы бинарные, ассоциативность и приоритет как обычно.

    Соотвественно операторы задают нам структуру AST
    ```
    AST = BINOP EXPR EXPR
    ```
    Скобки позволяют программисту расставлять порядок операций и парсятся как обычно.  


8. ## Пространство для маневра

    Эта Документация языка L имеет высшую синтаксическую силу, прямое действие и применяется всеми программистами на L. Соглашения и паттерны принимаемые сообществом программистов не должны противоречить действующей Документации. Однако, Документация может быть _обнулена_ и исправлена, при желании верховного создателя. 
    
